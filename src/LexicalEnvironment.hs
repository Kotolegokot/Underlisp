{-# LANGUAGE DeriveFunctor         #-}
{-# LANGUAGE DeriveTraversable     #-}
{-# LANGUAGE DeriveFoldable        #-}
{-# LANGUAGE FlexibleInstances     #-}
{-# LANGUAGE FlexibleContexts      #-}
{-# LANGUAGE UndecidableInstances  #-}
{-# LANGUAGE MultiParamTypeClasses #-}

module LexicalEnvironment where

import Data.Maybe (fromMaybe)
import Data.Map (Map)
import qualified Data.Map as Map
import Env
import Expr
import Callable
import LispShow

-- | Int denotes the last G-symbol generated by (gensym)
data LEnv a = LEnv Int [Map String a]
  deriving (Eq, Functor, Foldable, Traversable)

instance (LispShow a, Expr LEnv a) => LispShow (LEnv a) where
  lispShow (LEnv _ xs) = foldr (\(level, map) acc -> acc ++ "level " ++ show level ++ ":\n" ++ lispShow map ++ "\n")
                          ""
                          (zip [1..] xs)

instance (Expr LEnv a, LispShow a, Eq a) => Env LEnv a where
  empty            = LEnv 0 [Map.empty]
  fromList l       = LEnv 0 [Map.fromList l]
  pass (LEnv g xs) = LEnv g (Map.empty : xs)

  linsert key value (LEnv g (x:xs)) = LEnv g (x' : xs)
    where x' = fmap (\sexpr -> if isCallable sexpr
                               then case fromCallable sexpr of
                                      UserDefined e prototype sexprs bound
                                            -> callable $ UserDefined (linsert key value e) prototype sexprs bound
                                      other -> callable other
                               else sexpr)
               (Map.insert key value x)
  linsert _   _     (LEnv _ [])     = undefined

  xinsert key value (LEnv g (x:xs)) = LEnv g (x' : ext : xs)
    where ext = Map.fromList [(key, value)]
          x' = fmap (\sexpr -> if isCallable sexpr
                               then case fromCallable sexpr of
                                      UserDefined e prototype sexprs bound
                                            -> callable $ UserDefined (xinsert key value e) prototype sexprs bound
                                      other -> callable other
                               else sexpr)
               x
  xinsert _   _     (LEnv _ [])     = undefined

  lappend (LEnv g (x:xs)) add = LEnv g (x' : xs)
    where x' = fmap (\sexpr -> if isCallable sexpr
                               then case fromCallable sexpr of
                                      UserDefined e prototype sexprs bound
                                            -> callable $ UserDefined (lappend e add) prototype sexprs bound
                                      other -> callable other
                               else sexpr)
               (add `Map.union` x)
  lappend (LEnv _ [])     _   = undefined

  xappend (LEnv g (x:xs)) add = LEnv g (x' : add : xs)
    where x' = fmap (\sexpr -> if isCallable sexpr
                               then case fromCallable sexpr of
                                      UserDefined e prototype sexprs bound
                                            -> callable $ UserDefined (xappend e add) prototype sexprs bound
                                      other -> callable other
                               else sexpr)
               x
  xappend (LEnv _ [])     _   = undefined

  lexical  (LEnv _ (x:_ )) = x
  external (LEnv _ (_:xs)) = Map.unions xs
