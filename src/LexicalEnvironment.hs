{-# LANGUAGE DeriveFunctor         #-}
{-# LANGUAGE DeriveTraversable     #-}
{-# LANGUAGE DeriveFoldable        #-}
{-# LANGUAGE FlexibleInstances     #-}
{-# LANGUAGE FlexibleContexts      #-}
{-# LANGUAGE UndecidableInstances  #-}
{-# LANGUAGE MultiParamTypeClasses #-}

module LexicalEnvironment where

import Data.Maybe (fromMaybe)
import Data.Map (Map)
import qualified Data.Map as Map
import Env
import Expr
import Callable
import LispShow

-- | Int denotes the last G-symbol generated by (gensym)
-- | [String] is the list of program arguments
data LEnv a = LEnv Int [String] [Map String a]
  deriving (Eq, Functor, Foldable, Traversable)

setArgs :: [String] -> LEnv a -> LEnv a
setArgs args (LEnv g _ xs) = LEnv g args xs

getArgs :: LEnv a -> [String]
getArgs (LEnv _ args _) = args

getG :: LEnv a -> Int
getG (LEnv g _ _) = g

setG :: Int -> LEnv a -> LEnv a
setG g (LEnv _ args xs) = LEnv g args xs

instance (LispShow a, Expr LEnv a) => LispShow (LEnv a) where
  lispShow (LEnv _ _ xs) = foldr (\(level, map) acc -> acc ++ "level " ++ show level ++ ":\n" ++ lispShow map ++ "\n")
                           ""
                           (zip [1..] xs)

instance (Expr LEnv a, LispShow a, Eq a) => Env LEnv a where
  empty                 = LEnv 0 []   [Map.empty]
  fromList l            = LEnv 0 []   [Map.fromList l]
  pass (LEnv g args xs) = LEnv g args (Map.empty : xs)

  linsert key value (LEnv g args (x:xs)) = LEnv g args (x' : xs)
    where x' = fmap (\sexpr -> if isCallable sexpr
                               then case fromCallable sexpr of
                                      UserDefined e prototype sexprs bound
                                            -> callable $ UserDefined (linsert key value e) prototype sexprs bound
                                      other -> callable other
                               else sexpr)
               (Map.insert key value x)
  linsert _   _     (LEnv _ _ [])     = undefined

  xinsert key value (LEnv g args (x:xs)) = LEnv g args (x' : ext : xs)
    where ext = Map.fromList [(key, value)]
          x' = fmap (\sexpr -> if isCallable sexpr
                               then case fromCallable sexpr of
                                      UserDefined e prototype sexprs bound
                                            -> callable $ UserDefined (xinsert key value e) prototype sexprs bound
                                      other -> callable other
                               else sexpr)
               x
  xinsert _   _     (LEnv _ _ [])     = undefined

  lappend (LEnv g args (x:xs)) add = LEnv g args (x' : xs)
    where x' = fmap (\sexpr -> if isCallable sexpr
                               then case fromCallable sexpr of
                                      UserDefined e prototype sexprs bound
                                            -> callable $ UserDefined (lappend e add) prototype sexprs bound
                                      other -> callable other
                               else sexpr)
               (add `Map.union` x)
  lappend (LEnv _ _ [])     _   = undefined

  xappend (LEnv g args (x:xs)) add = LEnv g args (x' : add : xs)
    where x' = fmap (\sexpr -> if isCallable sexpr
                               then case fromCallable sexpr of
                                      UserDefined e prototype sexprs bound
                                            -> callable $ UserDefined (xappend e add) prototype sexprs bound
                                      other -> callable other
                               else sexpr)
               x
  xappend (LEnv _ _ [])     _   = undefined

  lexical  (LEnv _ _ (x:_ )) = x
  external (LEnv _ _ (_:xs)) = Map.unions xs
